# Rust Cloud Run Orchestrator - Justfile
# Run `just --list` to see all available commands

# Show all available commands
default:
    @just --list

# ============================================================================
# Build & Development
# ============================================================================

# Build the project (debug)
[group('build')]
build:
    cargo build

# Build release version
[group('build')]
build-release:
    cargo build --release

# Check compilation without building
[group('build')]
check:
    cargo check

# Run tests
[group('build')]
test:
    cargo test

# Format code
[group('build')]
fmt:
    cargo fmt

# Run clippy linter
[group('build')]
lint:
    cargo clippy

# Development workflow - rebuild and restart
[group('build')]
dev: build run

# ============================================================================
# Database
# ============================================================================

# Start PostgreSQL with Docker Compose
[group('database')]
db-start:
    docker compose up -d postgres
    @echo "Waiting for PostgreSQL to be ready..."
    @sleep 3

# Stop PostgreSQL
[group('database')]
db-stop:
    docker compose down

# Initialize database (run migrations)
[group('database')]
db-init: db-start
    cargo run -- init

# Reset database (WARNING: deletes all data)
[group('database')]
db-reset: db-stop
    docker compose down -v
    @echo "Database reset complete"

# Show database tables
[group('database')]
db-tables:
    docker compose exec postgres psql -U postgres -d orchestrator -c "\dt"

# Query workflows table
[group('database')]
db-workflows:
    docker compose exec postgres psql -U postgres -d orchestrator -c "SELECT id, name, cloud_run_job_name, executor_type FROM workflows;"

# Query runs table
[group('database')]
db-runs:
    docker compose exec postgres psql -U postgres -d orchestrator -c "SELECT id, workflow_id, status, created_at FROM runs ORDER BY created_at DESC LIMIT 10;"

# Query tasks for a specific run
[group('database')]
db-tasks run_id:
    docker compose exec postgres psql -U postgres -d orchestrator -c "SELECT task_index, status, cloud_run_execution_name, finished_at FROM tasks WHERE run_id = '{{run_id}}' ORDER BY task_index;"

# ============================================================================
# Orchestrator
# ============================================================================

# Run the orchestrator (default config)
[group('orchestrator')]
run: db-start
    cargo run -- run

# Run with optimized config (low-latency, low-memory)
[group('orchestrator')]
run-optimized: db-start
    @echo "Running with optimized config (2s poll, 50 batch, 5 concurrent)"
    RUST_LOG=info cargo run --release -- run

# Run with high-throughput config
[group('orchestrator')]
run-high-throughput: db-start
    @echo "Running with high-throughput config (5s poll, 500 batch, 50 concurrent)"
    RUST_LOG=info cargo run --release -- run

# ============================================================================
# Workflows & Runs
# ============================================================================

# List all workflows
[group('workflows')]
workflows:
    cargo run -- list-workflows

# Create example workflow (process executor)
[group('workflows')]
workflow-create-example:
    @cargo run -- create-workflow \
        --name "example-process" \
        --description "Example workflow with process executor" \
        --job-name "example-task.sh" \
        --project "local" \
        --region "local" \
        --task-count 5 \
        --executor process 2>/dev/null || echo "Workflow 'example-process' already exists (skipped)"

# Create Cloud Run workflow
[group('workflows')]
workflow-create name job project="my-project" region="us-central1" tasks="3":
    cargo run -- create-workflow \
        --name {{name}} \
        --job-name {{job}} \
        --project {{project}} \
        --region {{region}} \
        --task-count {{tasks}} \
        --executor cloudrun

# Trigger a workflow
[group('workflows')]
trigger workflow:
    cargo run -- trigger {{workflow}}

# Show all run statuses
[group('workflows')]
status:
    cargo run -- status

# Show status of specific run
[group('workflows')]
status-run run_id:
    cargo run -- status {{run_id}}

# Show runs for a workflow
[group('workflows')]
status-workflow workflow:
    cargo run -- status --workflow {{workflow}}

# Show tasks for a run
[group('workflows')]
tasks run_id:
    cargo run -- tasks {{run_id}}

# ============================================================================
# Docker
# ============================================================================

# Build Docker image
[group('docker')]
docker-build:
    docker build -t rust-orchestrator .

# Start all services with Docker Compose
[group('docker')]
docker-up:
    docker compose up -d
    @echo "Waiting for services to start..."
    @sleep 5
    docker compose exec orchestrator /app/rust-orchestrator init

# Stop all Docker services
[group('docker')]
docker-down:
    docker compose down

# Execute command in orchestrator container
[group('docker')]
docker-exec *ARGS:
    docker compose exec orchestrator /app/rust-orchestrator {{ARGS}}

# View orchestrator logs
[group('docker')]
docker-logs:
    docker compose logs -f orchestrator

# Create example workflow in Docker
[group('docker')]
docker-workflow-create:
    docker compose exec orchestrator /app/rust-orchestrator create-workflow \
        --name "docker-example" \
        --job-name "example-task" \
        --project "my-project" \
        --task-count 3 \
        --executor process

# Trigger workflow in Docker
[group('docker')]
docker-trigger workflow:
    docker compose exec orchestrator /app/rust-orchestrator trigger {{workflow}}

# View status in Docker
[group('docker')]
docker-status:
    docker compose exec orchestrator /app/rust-orchestrator status

# ============================================================================
# Testing & Setup
# ============================================================================

# Complete first-time setup
[group('setup')]
setup: db-start db-init test-script-create workflow-create-example
    @echo ""
    @echo "✓ Setup complete!"
    @echo ""
    @echo "Next steps:"
    @echo "  just trigger example-process  # Trigger the example workflow"
    @echo "  just run                      # Start the orchestrator"
    @echo "  just status                   # Check run status"

# Create test script for process executor
[group('setup')]
test-script-create:
    #!/usr/bin/env bash
    mkdir -p test-scripts
    cat > test-scripts/example-task.sh << 'EOF'
    #!/bin/bash
    echo "=========================================="
    echo "Task Execution Started"
    echo "=========================================="
    echo "Task index: ${task_index}"
    echo "Run ID: ${run_id}"
    echo "Workflow: ${workflow_name}"
    echo "Execution ID: ${EXECUTION_ID}"
    echo ""

    # Simulate some work
    echo "Processing data..."
    sleep 2

    echo "Task processing complete!"
    echo ""

    # Output result as JSON
    echo "Result:"
    echo '{"status": "success", "processed_items": 42, "task_index": "'${task_index}'"}'

    echo "=========================================="
    echo "Task Execution Completed"
    echo "=========================================="
    EOF
    chmod +x test-scripts/example-task.sh
    @echo "✓ Created test-scripts/example-task.sh"

# Run end-to-end test
[group('testing')]
test-e2e: db-start db-init test-script-create workflow-create-example
    #!/usr/bin/env bash
    set -e

    # Build binary once
    echo "Building binary..."
    cargo build --quiet

    BIN="../../target/debug/ork-cloud-run"

    # Cleanup function
    cleanup() {
        echo "Stopping orchestrator..."
        kill $ORCH_PID 2>/dev/null || true
    }
    trap cleanup EXIT

    echo "Starting orchestrator in background..."
    $BIN run &
    ORCH_PID=$!

    echo "Waiting for orchestrator to start..."
    sleep 3

    echo "Triggering workflow..."
    RUN_ID=$($BIN trigger example-process | grep "Run ID:" | awk '{print $3}')
    echo "Started run: $RUN_ID"

    echo "Waiting for tasks to complete..."
    sleep 10

    echo "Checking status..."
    $BIN status $RUN_ID
    $BIN tasks $RUN_ID

    cleanup

    echo ""
    echo "✓ Test complete!"

# Run load test (100 workflows)
[group('testing')]
test-load: db-start db-init workflow-create-example
    #!/usr/bin/env bash
    set -e

    # Build binary once to avoid spam
    echo "Building release binary..."
    cargo build --release --quiet

    BIN="../../target/release/ork-cloud-run"

    # Cleanup function
    cleanup() {
        echo ""
        echo "Cleaning up..."
        kill $ORCH_PID 2>/dev/null || true
        exit 0
    }
    trap cleanup INT TERM EXIT

    echo "Starting orchestrator..."
    $BIN run &
    ORCH_PID=$!
    sleep 2

    echo "Triggering 100 workflows..."
    for i in {1..100}; do
        $BIN trigger example-process >/dev/null &
    done
    wait

    echo "Monitoring for 30 seconds..."
    sleep 30

    echo ""
    $BIN status

    cleanup
    echo "✓ Load test complete"

# ============================================================================
# Cleanup
# ============================================================================

# Clean build artifacts
[group('cleanup')]
clean:
    cargo clean
    rm -rf target

# Clean test artifacts
[group('cleanup')]
clean-test:
    rm -rf test-scripts

# Clean everything (build + test + db)
[group('cleanup')]
clean-all: clean clean-test db-reset
    @echo "✓ All cleaned"
